// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package cache

import (
	"context"
	"os"
	"sync"
)

// Ensure, that ExecutorMock does implement Executor.
// If this is not the case, regenerate this file with moq.
var _ Executor = &ExecutorMock{}

// ExecutorMock is a mock implementation of Executor.
//
//	func TestSomethingThatUsesExecutor(t *testing.T) {
//
//		// make and configure a mocked Executor
//		mockedExecutor := &ExecutorMock{
//			DiskUsageFunc: func(ctx context.Context, path string) (DiskUsage, error) {
//				panic("mock out the DiskUsage method")
//			},
//			MkdirAllFunc: func(path string, perm os.FileMode) error {
//				panic("mock out the MkdirAll method")
//			},
//			MountFunc: func(ctx context.Context, from string, to string) error {
//				panic("mock out the Mount method")
//			},
//			RemoveAllFunc: func(name string) error {
//				panic("mock out the RemoveAll method")
//			},
//			StatFunc: func(name string) (os.FileInfo, error) {
//				panic("mock out the Stat method")
//			},
//			WriteFileFunc: func(name string, data []byte, perm os.FileMode) error {
//				panic("mock out the WriteFile method")
//			},
//		}
//
//		// use mockedExecutor in code that requires Executor
//		// and then make assertions.
//
//	}
type ExecutorMock struct {
	// DiskUsageFunc mocks the DiskUsage method.
	DiskUsageFunc func(ctx context.Context, path string) (DiskUsage, error)

	// MkdirAllFunc mocks the MkdirAll method.
	MkdirAllFunc func(path string, perm os.FileMode) error

	// MountFunc mocks the Mount method.
	MountFunc func(ctx context.Context, from string, to string) error

	// RemoveAllFunc mocks the RemoveAll method.
	RemoveAllFunc func(name string) error

	// StatFunc mocks the Stat method.
	StatFunc func(name string) (os.FileInfo, error)

	// WriteFileFunc mocks the WriteFile method.
	WriteFileFunc func(name string, data []byte, perm os.FileMode) error

	// calls tracks calls to the methods.
	calls struct {
		// DiskUsage holds details about calls to the DiskUsage method.
		DiskUsage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
		}
		// MkdirAll holds details about calls to the MkdirAll method.
		MkdirAll []struct {
			// Path is the path argument value.
			Path string
			// Perm is the perm argument value.
			Perm os.FileMode
		}
		// Mount holds details about calls to the Mount method.
		Mount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// From is the from argument value.
			From string
			// To is the to argument value.
			To string
		}
		// RemoveAll holds details about calls to the RemoveAll method.
		RemoveAll []struct {
			// Name is the name argument value.
			Name string
		}
		// Stat holds details about calls to the Stat method.
		Stat []struct {
			// Name is the name argument value.
			Name string
		}
		// WriteFile holds details about calls to the WriteFile method.
		WriteFile []struct {
			// Name is the name argument value.
			Name string
			// Data is the data argument value.
			Data []byte
			// Perm is the perm argument value.
			Perm os.FileMode
		}
	}
	lockDiskUsage sync.RWMutex
	lockMkdirAll  sync.RWMutex
	lockMount     sync.RWMutex
	lockRemoveAll sync.RWMutex
	lockStat      sync.RWMutex
	lockWriteFile sync.RWMutex
}

// DiskUsage calls DiskUsageFunc.
func (mock *ExecutorMock) DiskUsage(ctx context.Context, path string) (DiskUsage, error) {
	if mock.DiskUsageFunc == nil {
		panic("ExecutorMock.DiskUsageFunc: method is nil but Executor.DiskUsage was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Path string
	}{
		Ctx:  ctx,
		Path: path,
	}
	mock.lockDiskUsage.Lock()
	mock.calls.DiskUsage = append(mock.calls.DiskUsage, callInfo)
	mock.lockDiskUsage.Unlock()
	return mock.DiskUsageFunc(ctx, path)
}

// DiskUsageCalls gets all the calls that were made to DiskUsage.
// Check the length with:
//
//	len(mockedExecutor.DiskUsageCalls())
func (mock *ExecutorMock) DiskUsageCalls() []struct {
	Ctx  context.Context
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Path string
	}
	mock.lockDiskUsage.RLock()
	calls = mock.calls.DiskUsage
	mock.lockDiskUsage.RUnlock()
	return calls
}

// MkdirAll calls MkdirAllFunc.
func (mock *ExecutorMock) MkdirAll(path string, perm os.FileMode) error {
	if mock.MkdirAllFunc == nil {
		panic("ExecutorMock.MkdirAllFunc: method is nil but Executor.MkdirAll was just called")
	}
	callInfo := struct {
		Path string
		Perm os.FileMode
	}{
		Path: path,
		Perm: perm,
	}
	mock.lockMkdirAll.Lock()
	mock.calls.MkdirAll = append(mock.calls.MkdirAll, callInfo)
	mock.lockMkdirAll.Unlock()
	return mock.MkdirAllFunc(path, perm)
}

// MkdirAllCalls gets all the calls that were made to MkdirAll.
// Check the length with:
//
//	len(mockedExecutor.MkdirAllCalls())
func (mock *ExecutorMock) MkdirAllCalls() []struct {
	Path string
	Perm os.FileMode
} {
	var calls []struct {
		Path string
		Perm os.FileMode
	}
	mock.lockMkdirAll.RLock()
	calls = mock.calls.MkdirAll
	mock.lockMkdirAll.RUnlock()
	return calls
}

// Mount calls MountFunc.
func (mock *ExecutorMock) Mount(ctx context.Context, from string, to string) error {
	if mock.MountFunc == nil {
		panic("ExecutorMock.MountFunc: method is nil but Executor.Mount was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		From string
		To   string
	}{
		Ctx:  ctx,
		From: from,
		To:   to,
	}
	mock.lockMount.Lock()
	mock.calls.Mount = append(mock.calls.Mount, callInfo)
	mock.lockMount.Unlock()
	return mock.MountFunc(ctx, from, to)
}

// MountCalls gets all the calls that were made to Mount.
// Check the length with:
//
//	len(mockedExecutor.MountCalls())
func (mock *ExecutorMock) MountCalls() []struct {
	Ctx  context.Context
	From string
	To   string
} {
	var calls []struct {
		Ctx  context.Context
		From string
		To   string
	}
	mock.lockMount.RLock()
	calls = mock.calls.Mount
	mock.lockMount.RUnlock()
	return calls
}

// RemoveAll calls RemoveAllFunc.
func (mock *ExecutorMock) RemoveAll(name string) error {
	if mock.RemoveAllFunc == nil {
		panic("ExecutorMock.RemoveAllFunc: method is nil but Executor.RemoveAll was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockRemoveAll.Lock()
	mock.calls.RemoveAll = append(mock.calls.RemoveAll, callInfo)
	mock.lockRemoveAll.Unlock()
	return mock.RemoveAllFunc(name)
}

// RemoveAllCalls gets all the calls that were made to RemoveAll.
// Check the length with:
//
//	len(mockedExecutor.RemoveAllCalls())
func (mock *ExecutorMock) RemoveAllCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockRemoveAll.RLock()
	calls = mock.calls.RemoveAll
	mock.lockRemoveAll.RUnlock()
	return calls
}

// Stat calls StatFunc.
func (mock *ExecutorMock) Stat(name string) (os.FileInfo, error) {
	if mock.StatFunc == nil {
		panic("ExecutorMock.StatFunc: method is nil but Executor.Stat was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockStat.Lock()
	mock.calls.Stat = append(mock.calls.Stat, callInfo)
	mock.lockStat.Unlock()
	return mock.StatFunc(name)
}

// StatCalls gets all the calls that were made to Stat.
// Check the length with:
//
//	len(mockedExecutor.StatCalls())
func (mock *ExecutorMock) StatCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockStat.RLock()
	calls = mock.calls.Stat
	mock.lockStat.RUnlock()
	return calls
}

// WriteFile calls WriteFileFunc.
func (mock *ExecutorMock) WriteFile(name string, data []byte, perm os.FileMode) error {
	if mock.WriteFileFunc == nil {
		panic("ExecutorMock.WriteFileFunc: method is nil but Executor.WriteFile was just called")
	}
	callInfo := struct {
		Name string
		Data []byte
		Perm os.FileMode
	}{
		Name: name,
		Data: data,
		Perm: perm,
	}
	mock.lockWriteFile.Lock()
	mock.calls.WriteFile = append(mock.calls.WriteFile, callInfo)
	mock.lockWriteFile.Unlock()
	return mock.WriteFileFunc(name, data, perm)
}

// WriteFileCalls gets all the calls that were made to WriteFile.
// Check the length with:
//
//	len(mockedExecutor.WriteFileCalls())
func (mock *ExecutorMock) WriteFileCalls() []struct {
	Name string
	Data []byte
	Perm os.FileMode
} {
	var calls []struct {
		Name string
		Data []byte
		Perm os.FileMode
	}
	mock.lockWriteFile.RLock()
	calls = mock.calls.WriteFile
	mock.lockWriteFile.RUnlock()
	return calls
}
